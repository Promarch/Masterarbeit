Previously: 
- First two and a half weeks mainly network set-up und installing kernel
- Following week mainly first basic movement with python
- Some time was spent to set up the dockerfile
- Following week more advanced movement, like Multiple Waypoints or different cartesion coordinates
- Following week trying out impedance control on python, realising it might be impossible/very difficult, switching to c++
21.05.2024
Wrote a bit of code, mainly copying existing examples. 
Not really much output codewise, but I think I was able to understand quite a lot concerning the example codes. I should hopefully be able to finish my first own code tomorrow. 
22.05.2024
Modified existing code, setting a specific torque to a joint while having the others not move is working. 
Will look at quaternion video, hopefully I can start setting new trajectories tomorrow
23.05. 
Unsurprisingly, I did not look at the quaternion video.
Gutes Gespräch mit Niko, Idee ist, dass man quasi einen controller schreibt der von selbst den Workspace entdeckt. 
Die Terme von Niko waren mehr oder weniger, dass man im Joint Space die Kräfte vorgibt, und da durch die Kinematik einige Redundanzen gegeben sind man im Nullspace Bewegungen vorgeben kann. 
Alternatives Vorgehen ist, dass man einfach eine Viertelkugel abfährt und bei Widerstand einfach die nächste Bahn ansteuert und die gewollte Position abbricht. 
Rest des Tages wurde damit benutzt einen Halbkreis in python zu diskretisieren, damit man diesen morgen in den Roboter einprogrammiert. 

27.05
Vormittag nicht sehr produktiv, bisschen probiert zu überlegen wie ich's machen könnte, bin aber nicht wirklich weit gekommen. 
Nachmittags dann hauptsächlich Roboterdynamik angeschaut. Allgemein muss ich wahrscheinlich meine Roboterprogrammierung über die Jakobimatrizen machen, 
muss mir daher halt auch überlegen wie ich die Geschwindigkeiten im Arbeitsraum definiere damit sich diese sinnvoll auf die gelenkwinkel übersetzen. 
Allgemeine Frage die ich noch habe ist wie sie im Beispiel quasi die Gelenkgeschwindigkeiten berechnen, aber im Anschluss die Gelenkmomente angeben. 
28.05.
Vormittags Videos von Roboterdynamik angeschaut, Nachmittags dann versucht wieder den Roboter zu steuern. 
Gegen Ende hab ich's dann mit der Transformationsmatrix hinbekommen, aber es ist echt noch viel zu tun. 
29.05.
Vormittags damit verbracht rauszufinden wie man am besten einen Halbkreis programmiert, nur um herauszufinden dass es mit meiner Methode sehr schwierig wird.  
Idee: Ich definiere mir eine viertelkugel innerhalb dessen mein roboter sich bewegen darf. 
Sollte sich der Roboter ausserhalb dieser Kugel befinden wird ein fehler auf die gewünschte Geschwindigkeit addiert, damit man wieder zurück zur eigentlichen Kugel kommt. 
Davon abgesehen wird eine Geschwindigkeit im Arbeitsraum vorgegeben und mit der Jacobimatrix in den Gelenkraum projiziert. Wenn die Kraft einen gewissen Schwellwert überschreitet wird die Bewegung in dieser Richtung langsamer und eine zusätzliche Geschwindigkeit wird dazu geschaltet. Sollte die Kraft weitersteigen wird die entgegengesetzte Richtung angesteuert. 
31.05. 
Weitere Ideen:
- Muss ne Anlauf und Auslaufphase einplanen, da sich sonst mein Roboter über nicht kontinuierliche Beschleunigungen beschwert. 
- w_d könnte ein zufälliger Punkt auf der Viertelkugel sein, und die Geschwindigkeit werden dann durch (w_d-w) angepasst. Die Orientierung könnte man auch immer so angeben, dass die x-achse auf den Ursprung der Kugel zeigt. 
- Falls Kraft höher wird, versuchen die Geschwindigkeiten leicht zu modifizieren, wenn Kraft kleiner wird, weiter machen, wenn nicht, andere Richtung einschlagen, Bedingung wäre, dass die Richtung noch immer in Richtung w_d ist. 
Optimierung des vorherigen Punktes: (hier geht's vorerst nur um Geschwindigkeit, kp was ich mit der Positionsdifferenz mache). Die Richtung der Geschwindigkeit wird in einen tangentialen und senkrechten Anteil unterteilt. Der tangentiale Anteil ist proportional zur Kraft, die in die selbe Richtung wirkt. Falls ein hoher wiederstand da ist, wird die Kraft dementsprechend langsamer. Eine Idee könnte sein, dass es ein Minimum an Geschwindigkeit gibt, damit man bei zu hohen Kräften auch die Bewegung abbrechen kann (und dann einen neuen Punkt berechnet). Die senkrechte Geschwindigkeit besteht aus dem Vorzeichen und dem eigentlichen Wert. Ähnlich dem tangentialen Anteil ist die Geschwindigkeit vom senkrechten Anteil proportional zur Kraft in die Richtung, mit dem Unterschied dass wenn die Kraft erreicht ist sich das Vorzeichen ändert und der Roboter in die andere Richtung fährt. Ich wüsste in dem Fall ehrlich gesagt auch nicht wofür ich w_d verwenden würde, da ich die Differenz ja mehr oder weniger in den ganzen bums einbaue. Vielleicht dass der Roboter langsamer wird wenn er in die nähe des Ziels kommt, damit es nicht zu einem brutalen Richtungswechsel kommt wenn ein neues Ziel eingetragen wird. 

06.06
Weitere Idee: 
- Während der if-Schleife nicht dq_d regeln, sonder dq_soll, und dann nach der if_schleife die abrupten geschwindigkeitswechsel abfangen. 
11.06
Niko meinte bei der letzten Besprechung, dass ich nicht unbedingt positionen, sondern eher orientierungen regeln soll, also quasi dass man 60 grad flexion ausprobiert, oder 10 grad torsion. Dazu könnte man über den Nullspace noch die Kraft regeln, so dass sie nicht über 5N kommt. Gerade ist's aber echt schwierig, da ich momentan versuche direkt die Kräfte zu regeln, indem ich die differenz zwischen soll und ist-Zustand mache, die mit nem proportionalfaktor dann über die Jacobimatrix auf die Joint projiziere. Habs gerade ausprobiert, der Roboter ist direkt überdreht und durch zu hohe geschwindigkeit zum stopp gekommen. 

14.06
Heute ging deutlich besser, kraftregelung funktioniert ungefähr, ist aus dem Buch handbook of robotics, kapitel 7. Reines stiffness control, keine Kraftbeschränkung oder so ähnlich. 
Mit dem Gummiband funktioniert es schon relativ gut, als nächstes müsste ich schauen, wie ich Steifigkeiten selektiv einstellen kann damit ich zB in y eine position angebe und es sich einfacher in z-richtung verschieben lässt. 
Im anschluss wäre es noch interessant zu testen, ob es funktioniert rotationen anzugeben. 
Ab da kann's dann Richtung Kniemanipulation gehen, wobei ich hier wahrscheinlich eine bessere Aufhängung brauche, da ich nicht denke dass die jetzige gut mit Rotationen auskommt. Allgemeine Dimensionen stimmen, aber ich müsste die Löcher zum greifen tiefer machen. 

17.06. 
Kraftregelung funktioniert ungefähr, Relative positionen werden angefahre, positionen auch, wobei ich hier immer wieder probleme mit der Torque kontnuität habe. Mögliche Lösung wäre die gesendeten Momente über die letzten 5 Werte zu mitteln, dazu gibt es auch ein Beispiel in LibFranka. Im Moment werden Rotationen noch um den Greifer gemacht, was den Nachteil hat, dass man ein enormes Moment aufbringt da in Realität nicht um den Greifer sondern um das Rotationszentrum im Kniegelenk rotiert wird. 
18.06.
Viel 3D modellierung, Aufhängung für die Marker gemacht, die Löcher für die Halterung am Knie neu dimensioniert, und die spacer am greifarm konstruiert. 
Niko meinte auch, dass eine elegante Lösung für mein Rotationsproblem eine modifizierung der Jakobimatrix wäre, indem man als Position des End-Effektors nicht die greifer nimmt, sondern das Rotationszentrum des Kniegelenks.
19.06.
Großer 3D Druck ist über Nacht fehlgeschlagen, da sich die Rolle verknotet hat und dadurch stecken geblieben ist. Durfte dadurch heute hauptsächlich den Bowdentube entfernen und einen Teil rausschneiden.
Southside, daher wenig gemacht 
Ikom woche, daher nur halbtags da
24.06.
Nur kurz da gewesen, End-Effektor in Libfranka angepasst damit die Rotation ungefähr ums Kniegelenk hin passiert und nicht um die Greifer
25.06.
Neues Script in python um den Verlauf der Momente in den jeweiligen Gelenken zu messen, ForceControl angepasst dass es auch diese Werte ausgibt, dazu auch die Steifigkeit angepasst damit kein controller torque discontinuity aufkommt
